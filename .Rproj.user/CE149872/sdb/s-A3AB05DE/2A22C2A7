{
    "collab_server" : "",
    "contents" : "// -*- mode: C++; c-indent-level: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-\n/* :tabSize=4:indentSize=4:noTabs=false:folding=explicit:collapseFolds=1: */\n//\n// wrap.h: Rcpp R/C++ interface class library -- wrap implementations\n//\n// Copyright (C) 2010 - 2017  Dirk Eddelbuettel and Romain Francois\n//\n// This file is part of Rcpp.\n//\n// Rcpp is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// Rcpp is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Rcpp.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef Rcpp_internal_wrap_h\n#define Rcpp_internal_wrap_h\n\n#include <iterator>\n\n// this is a private header, included in RcppCommon.h\n// don't include it directly\n\nnamespace Rcpp {\n\n    namespace RcppEigen {\n        template <typename T> SEXP eigen_wrap(const T& object);\n    }\n\n    template <typename T> SEXP wrap(const T& object);\n\n    template <typename T> class CustomImporter;\n\n    namespace internal {\n\n        inline SEXP make_charsexp__impl__wstring(const wchar_t* data) {\n            char* buffer = get_string_buffer();\n            wcstombs(buffer, data, MAXELTSIZE);\n            return Rf_mkChar(buffer);\n        }\n        inline SEXP make_charsexp__impl__wstring(wchar_t data) {\n            wchar_t x[2]; x[0] = data; x[1] = '\\0';\n            char* buffer = get_string_buffer();\n            wcstombs(buffer, x, MAXELTSIZE);\n            return Rf_mkChar(buffer);\n        }\n        inline SEXP make_charsexp__impl__wstring(const std::wstring& st) {\n            return make_charsexp__impl__wstring(st.data());\n        }\n        inline SEXP make_charsexp__impl__cstring(const char* data) {\n            return Rf_mkChar(data);\n        }\n    \tinline SEXP make_charsexp__impl__cstring(char data) {\n            char x[2]; x[0] = data; x[1] = '\\0';\n            return Rf_mkChar(x);\n        }\n\n    \tinline SEXP make_charsexp__impl__cstring(const std::string& st) {\n            return make_charsexp__impl__cstring(st.c_str());\n        }\n\n    \ttemplate <typename T>\n    \tinline SEXP make_charsexp__impl(const T& s, Rcpp::traits::true_type) {\n            return make_charsexp__impl__wstring(s);\n        }\n\n    \ttemplate <typename T>\n        inline SEXP make_charsexp__impl(const T& s, Rcpp::traits::false_type) {\n            return make_charsexp__impl__cstring(s);\n        }\n\n\ttemplate <typename T>\n\tinline SEXP make_charsexp(const T& s) {\n            return make_charsexp__impl<T>(s, typename Rcpp::traits::is_wide_string<T>::type());\n\t}\n\ttemplate <>\n\tinline SEXP make_charsexp<Rcpp::String>(const Rcpp::String&);\n\n\ttemplate <typename InputIterator> SEXP range_wrap(InputIterator first, InputIterator last);\n\ttemplate <typename InputIterator> SEXP rowmajor_wrap(InputIterator first, int nrow, int ncol);\n\n    \t// {{{ range wrap\n    \t// {{{ unnamed range wrap\n\n    \t/**\n         * Range based primitive wrap implementation. used when\n         * - T is a primitive type, indicated by the r_type_traits\n         * - T needs a static_cast to be of the type suitable to fit in the R vector\n         *\n         * This produces an unnamed vector of the appropriate type using the\n         * std::transform algorithm\n         */\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP primitive_range_wrap__impl(InputIterator first, InputIterator last,\n                                               ::Rcpp::traits::true_type) {\n            size_t size = std::distance(first, last);\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<T>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, size));\n            std::transform(first, last, r_vector_start<RTYPE>(x), caster< T,\n                           typename ::Rcpp::traits::storage_type<RTYPE>::type >);\n            return wrap_extra_steps<T>(x);\n        }\n\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP primitive_range_wrap__impl__nocast(InputIterator first, InputIterator last,\n                                                       std::random_access_iterator_tag) {\n            size_t size = std::distance(first, last);\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<T>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, size));\n\n            typedef typename ::Rcpp::traits::storage_type<RTYPE>::type STORAGE;\n            R_xlen_t __trip_count = size >> 2;\n            STORAGE* start = r_vector_start<RTYPE>(x);\n            R_xlen_t i = 0;\n            for (; __trip_count > 0; --__trip_count) {\n                start[i] = first[i]; i++;\n                start[i] = first[i]; i++;\n                start[i] = first[i]; i++;\n                start[i] = first[i]; i++;\n            }\n            switch (size - i) {\n            case 3:\n                start[i] = first[i]; i++;\n                // fallthrough\n            case 2:\n                start[i] = first[i]; i++;\n                // fallthrough\n            case 1:\n                start[i] = first[i]; i++;\n                // fallthrough\n            case 0:\n            default:\n                {}\n            }\n\n            return wrap_extra_steps<T>(x);\n        }\n\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP primitive_range_wrap__impl__nocast(InputIterator first, InputIterator last,\n                                                       std::input_iterator_tag) {\n            size_t size = std::distance(first, last);\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<T>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, size));\n            std::copy(first, last, r_vector_start<RTYPE>(x));\n            return wrap_extra_steps<T>(x);\n        }\n\n    \t/**\n         * Range based primitive wrap implementation. used when :\n         * - T is a primitive type\n         * - T does not need a cast\n         *\n         * This produces an unnamed vector of the appropriate type using\n         * the std::copy algorithm\n         */\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP primitive_range_wrap__impl(InputIterator first, InputIterator last,\n                                               ::Rcpp::traits::false_type) {\n            return primitive_range_wrap__impl__nocast<InputIterator,T>(first, last, typename std::iterator_traits<InputIterator>::iterator_category());\n        }\n\n\n    \t/**\n         * Range based wrap implementation that deals with iterator over\n         * primitive types (int, double, etc ...)\n         *\n         * This produces an unnamed vector of the appropriate type\n         */\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_primitive_tag) {\n            return primitive_range_wrap__impl<InputIterator,T>(first, last, typename ::Rcpp::traits::r_sexptype_needscast<T>());\n        }\n\n    \t/**\n         * range based wrap implementation that deals with iterators over\n         * some type U. each U object is itself wrapped\n         *\n         * This produces an unnamed generic vector (list)\n         */\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___generic(InputIterator first, InputIterator last) {\n            size_t size = std::distance(first, last);\n            Shield<SEXP> x(Rf_allocVector(VECSXP, size));\n            size_t i =0;\n            while(i < size) {\n                SET_VECTOR_ELT(x, i, ::Rcpp::wrap(*first));\n\t\ti++;\n\t\t++first;\n            }\n            return x;\n        }\n\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_generic_tag) {\n            return range_wrap_dispatch___generic<InputIterator, T>(first, last);\n        }\n\n    \t// modules\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_module_object_pointer_tag) {\n            return range_wrap_dispatch___generic<InputIterator, T>(first, last);\n        }\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_module_object_const_pointer_tag) {\n            return range_wrap_dispatch___generic<InputIterator, T>(first, last);\n        }\n        template <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_module_object_tag) {\n            return range_wrap_dispatch___generic<InputIterator, T>(first, last);\n        }\n\ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_module_object_reference_tag) {\n            return range_wrap_dispatch___generic<InputIterator, T>(first, last);\n        }\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_module_object_const_reference_tag) {\n            return range_wrap_dispatch___generic<InputIterator, T>(first, last);\n        }\n\n\n\n    \t/**\n         * Range based wrap implementation for iterators over std::string\n         *\n         * This produces an unnamed character vector\n         */\n    \ttemplate<typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_string_tag) {\n            size_t size = std::distance(first, last);\n            Shield<SEXP> x(Rf_allocVector(STRSXP, size));\n            size_t i = 0;\n            while(i < size) {\n\t\tSET_STRING_ELT(x, i, make_charsexp(*first));\n\t\ti++;\n\t\t++first;\n            }\n            return x;\n        }\n\n    \t// }}}\n\n    \t// {{{ named range wrap\n\n    \t/**\n         * range based wrap implementation that deals with iterators over\n         * pair<const string,T> where T is a primitive type : int, double ...\n         *\n         * This version is used when there is no need to cast T\n         *\n         * This produces a named R vector of the appropriate type\n         */\n    \ttemplate <typename InputIterator, typename T> \t\t// #nocov start\n        inline SEXP range_wrap_dispatch___impl__cast(InputIterator first, InputIterator last, ::Rcpp::traits::false_type) {\n            size_t size = std::distance(first, last);\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<typename T::second_type>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, size));\n            Shield<SEXP> names(Rf_allocVector(STRSXP, size));\n            typedef typename ::Rcpp::traits::storage_type<RTYPE>::type CTYPE;\n            CTYPE* start = r_vector_start<RTYPE>(x);\n            size_t i =0;\n            std::string buf;\n            for (; i<size; i++, ++first) {\n\t\tstart[i] = (*first).second;\n\t\tbuf = (*first).first;\n\t\tSET_STRING_ELT(names, i, Rf_mkChar(buf.c_str()));\n            }\n            ::Rf_setAttrib(x, R_NamesSymbol, names);\n            return wrap_extra_steps<T>(x); \t\t// #nocov end\n        }\n\n    \t/**\n         * range based wrap implementation that deals with iterators over\n         * pair<const string,T> where T is a primitive type : int, double ...\n         *\n         * This version is used when T needs to be cast to the associated R\n         * type\n         *\n         * This produces a named R vector of the appropriate type\n         */\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl__cast(InputIterator first, InputIterator last, ::Rcpp::traits::true_type) {\n            size_t size = std::distance(first, last);\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<typename T::second_type>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, size));\n            Shield<SEXP> names(Rf_allocVector(STRSXP, size));\n            typedef typename ::Rcpp::traits::storage_type<RTYPE>::type CTYPE;\n            CTYPE* start = r_vector_start<RTYPE>(x);\n            size_t i =0;\n            std::string buf;\n            for (; i<size; i++, ++first) {\n\t\tstart[i] = static_cast<CTYPE>(first->second);\n\t\tbuf = first->first;\n\t\tSET_STRING_ELT(names, i, Rf_mkChar(buf.c_str()));\n            }\n            ::Rf_setAttrib(x, R_NamesSymbol, names);\n            return wrap_extra_steps<T>(x);\n        }\n\n\n    \t/**\n         * range based wrap implementation that deals with iterators over\n         * pair<const string,T> where T is a primitive type : int, double ...\n         *\n         * This dispatches further depending on whether the type needs\n         * a cast to fit into the associated R type\n         *\n         * This produces a named R vector of the appropriate type\n         */\n    \ttemplate <typename InputIterator, typename T> \t\t// #nocov start\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_pairstring_primitive_tag) {\n            return range_wrap_dispatch___impl__cast<InputIterator,T>(first, last,\n                                                                     typename ::Rcpp::traits::r_sexptype_needscast<typename T::second_type>());\n        } \t\t\t\t\t\t\t// #nocov end\n\n    \t/**\n         * Range based wrap implementation that deals with iterators over\n         * pair<const string, U> where U is wrappable. This is the kind of\n         * iterators that are produced by map<string,U>\n         *\n         * This produces a named generic vector (named list). The first\n         * element of the list contains the result of a call to wrap on the\n         * object of type U, etc ...\n         *\n         * The names are taken from the keys\n         */\n    \ttemplate <typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_pairstring_generic_tag) {\n            size_t size = std::distance(first, last);\n            Shield<SEXP> x(Rf_allocVector(VECSXP, size));\n            Shield<SEXP> names(Rf_allocVector(STRSXP, size));\n            size_t i =0;\n            std::string buf;\n            SEXP element = R_NilValue;\n            while(i < size) {      \t\t\t\t// #nocov start\n\t\telement = ::Rcpp::wrap(first->second);\n\t\tbuf = first->first;\n\t\tSET_VECTOR_ELT(x, i, element);\n\t\tSET_STRING_ELT(names, i, Rf_mkChar(buf.c_str()));\n\t\ti++;\n\t\t++first;\n            } \t\t\t\t\t\t\t// #nocov end\n            ::Rf_setAttrib(x, R_NamesSymbol, names);\n            return x;\n        }\n\n\n    \t/**\n         * Range based wrap for iterators over std::pair<const std::(w)?string, std::(w)?string>\n         *\n         * This is mainly used for wrapping map<string,string> and friends\n         * which happens to produce iterators over pair<const string, string>\n         *\n         * This produces a character vector containing copies of the\n         * string iterated over. The names of the vector is set to the keys\n         * of the pair\n         */\n    \ttemplate<typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_pairstring_string_tag) {\n            size_t size = std::distance(first, last);\n            Shield<SEXP> x(Rf_allocVector(STRSXP, size));\n            Shield<SEXP> names(Rf_allocVector(STRSXP, size));\n            for (size_t i = 0; i < size; i++, ++first) {\n\t\tSET_STRING_ELT(x, i, make_charsexp(first->second));\n\t\tSET_STRING_ELT(names, i, make_charsexp(first->first));\n            }\n            ::Rf_setAttrib(x, R_NamesSymbol, names);\n            return x;\n        }\n\n    \t/**\n         * iterating over pair<const int, VALUE>\n         * where VALUE is some primitive type\n         */\n    \ttemplate <typename InputIterator, typename KEY, typename VALUE, int RTYPE>\n        inline SEXP range_wrap_dispatch___impl__pair(InputIterator first, InputIterator last, Rcpp::traits::true_type);\n\n    \t/**\n         * iterating over pair<const int, VALUE>\n         * where VALUE is a type that needs wrapping\n         */\n    \ttemplate <typename InputIterator, typename KEY, typename VALUE, int RTYPE>\n        inline SEXP range_wrap_dispatch___impl__pair(InputIterator first, InputIterator last, Rcpp::traits::false_type);\n\n\n    \t/**\n         * Range wrap dispatch for iterators over std::pair<const int, T>\n         */\n    \ttemplate<typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch___impl(InputIterator first, InputIterator last, ::Rcpp::traits::r_type_pair_tag) {\n            typedef typename T::second_type VALUE;\n            typedef typename T::first_type KEY;\n\n            return range_wrap_dispatch___impl__pair<InputIterator, KEY, VALUE,\n                                                    Rcpp::traits::r_sexptype_traits<VALUE>::rtype >(first, last,\n                                                                                                    typename Rcpp::traits::is_primitive<VALUE>::type());\n        }\n\n    \t// }}}\n\n    \t/**\n         * Dispatcher for all range based wrap implementations\n         *\n         * This uses the Rcpp::traits::r_type_traits to perform further dispatch\n         */\n    \ttemplate<typename InputIterator, typename T>\n        inline SEXP range_wrap_dispatch(InputIterator first, InputIterator last) {\n\t#if RCPP_DEBUG_LEVEL > 0\n            typedef typename ::Rcpp::traits::r_type_traits<T>::r_category categ;\n\t#endif\n            RCPP_DEBUG_3(\"range_wrap_dispatch< InputIterator = \\n%s , T = %s, categ = %s>\\n\", DEMANGLE(InputIterator), DEMANGLE(T), DEMANGLE(categ));\n            return range_wrap_dispatch___impl<InputIterator,T>(first, last, typename ::Rcpp::traits::r_type_traits<T>::r_category());\n        }\n\n    \t// we use the iterator trait to make the dispatch\n    \t/**\n         * range based wrap. This uses the std::iterator_traits class\n         * to perform further dispatch\n         */\n    \ttemplate <typename InputIterator>\n        inline SEXP range_wrap(InputIterator first, InputIterator last) {\n            return range_wrap_dispatch<InputIterator,typename traits::remove_reference<typename std::iterator_traits<InputIterator>::value_type>::type >(first, last);\n        }\n    \t// }}}\n\n    \t// {{{ primitive wrap (wrapping a single primitive value)\n\n    \t/**\n         * wraps a single primitive value when there is no need for a cast\n         */\n    \ttemplate <typename T>\n        inline SEXP primitive_wrap__impl__cast(const T& object, ::Rcpp::traits::false_type) {\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<T>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, 1));\n            r_vector_start<RTYPE>(x)[0] = object;\n            return x;\n        }\n\n    \t/**\n         * wraps a single primitive value when a cast is needed\n         */\n    \ttemplate <typename T>\n        inline SEXP primitive_wrap__impl__cast(const T& object, ::Rcpp::traits::true_type) {\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<T>::rtype;\n            typedef typename ::Rcpp::traits::storage_type<RTYPE>::type STORAGE_TYPE;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, 1));\n            r_vector_start<RTYPE>(x)[0] = caster<T,STORAGE_TYPE>(object);\n            return x;\n        }\n\n    \t/**\n         * primitive wrap for 'easy' primitive types: int, double, Rbyte, Rcomplex\n         *\n         * This produces a vector of length 1 of the appropriate type\n         */\n\ttemplate <typename T>\n\tinline SEXP primitive_wrap__impl(const T& object, ::Rcpp::traits::r_type_primitive_tag) {\n            return primitive_wrap__impl__cast(object, typename ::Rcpp::traits::r_sexptype_needscast<T>());\n        }\n\n\t/**\n         * primitive wrap for types that can be converted implicitely to std::string or std::wstring\n         *\n         * This produces a character vector of length 1 containing the std::string or wstring\n         */\n\ttemplate <typename T>\n        inline SEXP primitive_wrap__impl(const T& object, ::Rcpp::traits::r_type_string_tag) {\n            Shield<SEXP> x(::Rf_allocVector(STRSXP, 1));\n            SET_STRING_ELT(x, 0, make_charsexp(object));\n            return x;\n        }\n\n\n\t/**\n         * called when T is a primitive type : int, bool, double, std::string, etc ...\n         * This uses the Rcpp::traits::r_type_traits on the type T to perform\n         * further dispatching and wrap the object into an vector of length 1\n         * of the appropriate SEXP type\n         */\n\ttemplate <typename T>\n        inline SEXP primitive_wrap(const T& object) {\n            return primitive_wrap__impl(object, typename ::Rcpp::traits::r_type_traits<T>::r_category());\n        }\n\t// }}}\n\n\t// {{{ unknown\n\t/**\n         * Called when the type T is known to be implicitely convertible to\n         * SEXP. It uses the implicit conversion to SEXP to wrap the object\n         * into a SEXP\n         */\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown(const T& object, ::Rcpp::traits::true_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown<%s>(., false )\", DEMANGLE(T))\n            // here we know (or assume) that T is convertible to SEXP\n            SEXP x = object;\n            return x;\n        }\n\n\t/**\n         * This is the worst case :\n         * - not a primitive\n         * - not implicitely convertible tp SEXP\n         * - not iterable\n         *\n         * so we just give up and attempt to use static_assert to generate\n         * a compile time message if it is available, otherwise we use\n         * implicit conversion to SEXP to bomb the compiler, which will give\n         * quite a cryptic message\n         */\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown_iterable(const T& object, ::Rcpp::traits::false_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown_iterable<%s>(., false )\", DEMANGLE(T))\n\t    // here we know that T is not convertible to SEXP\n\t    #ifdef HAS_STATIC_ASSERT\n                static_assert(!sizeof(T), \"cannot convert type to SEXP\");\n            #else\n                // leave the cryptic message\n                SEXP x = object;\n                return x;\n            #endif\n            return R_NilValue; // -Wall\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown_iterable__logical(const T& object, ::Rcpp::traits::true_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown_iterable__logical<%s>(., true )\", DEMANGLE(T))\n            size_t size = object.size();\n            Shield<SEXP> x(Rf_allocVector(LGLSXP, size));\n            std::copy(object.begin(), object.end(), LOGICAL(x));\n            return x;\n        }\n\n\ttemplate <typename T>\n\tinline SEXP wrap_range_sugar_expression(const T& object, Rcpp::traits::false_type) {\n            RCPP_DEBUG_1(\"wrap_range_sugar_expression<%s>(., false )\", DEMANGLE(T))\n\t    return range_wrap(object.begin(), object.end());\n        }\n\ttemplate <typename T>\n        inline SEXP wrap_range_sugar_expression(const T& object, Rcpp::traits::true_type);\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown_iterable__logical(const T& object, ::Rcpp::traits::false_type) {\n\t    RCPP_DEBUG_1(\"wrap_dispatch_unknown_iterable__logical<%s>(., false )\", DEMANGLE(T))\n            return wrap_range_sugar_expression(object, typename Rcpp::traits::is_sugar_expression<T>::type());\n        }\n\n\n\ttemplate <typename T>\n\tinline SEXP wrap_dispatch_unknown_iterable__matrix_interface(const T& object, ::Rcpp::traits::false_type) {\n\t    RCPP_DEBUG_1(\"wrap_dispatch_unknown_iterable__matrix_interface<%s>(., false )\", DEMANGLE(T))\n            return wrap_dispatch_unknown_iterable__logical(object,\n                                                           typename ::Rcpp::traits::expands_to_logical<T>::type());\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_matrix_logical(const T& object, ::Rcpp::traits::true_type) {\n            int nr = object.nrow(), nc = object.ncol();\n            Shield<SEXP> res(Rf_allocVector(LGLSXP, nr * nc));\n            int k=0;\n            int* p = LOGICAL(res);\n            for (int j=0; j<nc; j++)\n\t\tfor (int i=0; i<nr; i++, k++)\n                    p[k] = object(i,j);\n            Shield<SEXP> dim(Rf_allocVector(INTSXP, 2));\n            INTEGER(dim)[0] = nr;\n            INTEGER(dim)[1] = nc;\n            Rf_setAttrib(res, R_DimSymbol , dim);\n            return res;\n        }\n\n\ttemplate <typename T, typename STORAGE>\n        inline SEXP wrap_dispatch_matrix_primitive(const T& object) {\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<STORAGE>::rtype;\n            int nr = object.nrow(), nc = object.ncol();\n            Shield<SEXP> res(Rf_allocVector(RTYPE, nr*nc));\n\n            int k=0;\n            STORAGE* p = r_vector_start< RTYPE>(res);\n            for (int j=0; j<nc; j++)\n\t\tfor (int i=0; i<nr; i++, k++)\n                    p[k] = object(i,j);\n            Shield<SEXP> dim(Rf_allocVector(INTSXP, 2));\n            INTEGER(dim)[0] = nr;\n            INTEGER(dim)[1] = nc;\n            Rf_setAttrib(res, R_DimSymbol , dim);\n            return res;\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_matrix_not_logical(const T& object, ::Rcpp::traits::r_type_primitive_tag) {\n            return wrap_dispatch_matrix_primitive<T, typename T::stored_type>(object);\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_matrix_not_logical(const T& object, ::Rcpp::traits::r_type_string_tag) {\n            int nr = object.nrow(), nc = object.ncol();\n            Shield<SEXP> res(Rf_allocVector(STRSXP, nr*nc));\n\n            int k=0;\n            for (int j=0; j<nc; j++)\n\t\tfor (int i=0; i<nr; i++, k++)\n                    SET_STRING_ELT(res, k, make_charsexp(object(i,j)));\n            Shield<SEXP> dim(Rf_allocVector(INTSXP, 2));\n            INTEGER(dim)[0] = nr;\n            INTEGER(dim)[1] = nc;\n            Rf_setAttrib(res, R_DimSymbol , dim);\n            return res;\n        }\n\n    \ttemplate <typename T>\n        inline SEXP wrap_dispatch_matrix_not_logical(const T& object, ::Rcpp::traits::r_type_generic_tag) {\n            int nr = object.nrow(), nc = object.ncol();\n            Shield<SEXP> res(Rf_allocVector(VECSXP, nr*nc));\n\n            int k=0;\n            for (int j=0; j<nc; j++)\n\t\tfor (int i=0; i<nr; i++, k++)\n                    SET_VECTOR_ELT(res, k, ::Rcpp::wrap(object(i,j)));\n            Shield<SEXP> dim(Rf_allocVector(INTSXP, 2));\n            INTEGER(dim)[0] = nr;\n            INTEGER(dim)[1] = nc;\n            Rf_setAttrib(res, R_DimSymbol , dim);\n            return res;\n        }\n\n    \ttemplate <typename T>\n        inline SEXP wrap_dispatch_matrix_logical(const T& object, ::Rcpp::traits::false_type) {\n            return wrap_dispatch_matrix_not_logical<T>(object, typename ::Rcpp::traits::r_type_traits<typename T::stored_type>::r_category());\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown_iterable__matrix_interface(const T& object, ::Rcpp::traits::true_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown_iterable__matrix_interface<%s>(., true )\", DEMANGLE(T))\n\t    return wrap_dispatch_matrix_logical(object, typename ::Rcpp::traits::expands_to_logical<T>::type());\n        }\n\n\n\t/**\n         * Here we know for sure that type T has a T::iterator typedef\n         * so we hope for the best and call the range based wrap with begin\n         * and end\n         *\n         * This works fine for all stl containers and classes T that have :\n         * - T::iterator\n         * - T::iterator begin()\n         * - T::iterator end()\n         *\n         * If someone knows a better way, please advise\n         */\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown_iterable(const T& object, ::Rcpp::traits::true_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown_iterable<%s>(., true )\", DEMANGLE(T))\n            return wrap_dispatch_unknown_iterable__matrix_interface(object,\n                                                                    typename ::Rcpp::traits::matrix_interface<T>::type());\n        }\n\n\ttemplate <typename T, typename elem_type>\n        inline SEXP wrap_dispatch_importer__impl__prim(const T& object, ::Rcpp::traits::false_type) {\n            int size = object.size();\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<elem_type>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, size));\n            typedef typename ::Rcpp::traits::storage_type<RTYPE>::type CTYPE;\n            CTYPE* start = r_vector_start<RTYPE>(x);\n            for (int i=0; i<size; i++) {\n\t\tstart[i] = object.get(i);\n            }\n            return x;\n\n        }\n\n    \ttemplate <typename T, typename elem_type>\n    \tinline SEXP wrap_dispatch_importer__impl__prim(const T& object, ::Rcpp::traits::true_type) {\n            int size = object.size();\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<elem_type>::rtype;\n            Shield<SEXP> x(Rf_allocVector(RTYPE, size));\n            typedef typename ::Rcpp::traits::storage_type<RTYPE>::type CTYPE;\n            CTYPE* start = r_vector_start<RTYPE>(x);\n            for (int i=0; i<size; i++) {\n\t\tstart[i] = caster<elem_type,CTYPE>(object.get(i));\n            }\n            return x;\n        }\n\n\ttemplate <typename T, typename elem_type>\n\tinline SEXP wrap_dispatch_importer__impl(const T& object, ::Rcpp::traits::r_type_primitive_tag) {\n            return wrap_dispatch_importer__impl__prim<T,elem_type>(object,\n                                                                   typename ::Rcpp::traits::r_sexptype_needscast<elem_type>());\n        }\n\n\ttemplate <typename T, typename elem_type>\n        inline SEXP wrap_dispatch_importer__impl(const T& object, ::Rcpp::traits::r_type_string_tag) {\n            int size = object.size();\n            Shield<SEXP> x(Rf_allocVector(STRSXP, size));\n            for (int i=0; i<size; i++) {\n\t\tSET_STRING_ELT(x, i, make_charsexp(object.get(i)));\n            }\n            return x;\n        }\n\n    \ttemplate <typename T, typename elem_type>\n    \tinline SEXP wrap_dispatch_importer__impl(const T& object, ::Rcpp::traits::r_type_generic_tag) {\n            int size = object.size();\n            Shield<SEXP> x(Rf_allocVector(VECSXP, size));\n            for (int i=0; i<size; i++) {\n\t\tSET_VECTOR_ELT(x, i, object.wrap(i));\n            }\n            return x;\n\t}\n\n    \ttemplate <typename T, typename elem_type>\n        inline SEXP wrap_dispatch_importer(const T& object) {\n            return wrap_dispatch_importer__impl<T,elem_type>(object,\n                                                             typename ::Rcpp::traits::r_type_traits<elem_type>::r_category());\n        }\n\n\t/**\n         * Called when no implicit conversion to SEXP is possible and this is\n         * not tagged as a primitive type, checks whether the type is\n         * iterable\n         */\n    \ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown(const T& object, ::Rcpp::traits::false_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown<%s>(., false )\", DEMANGLE(T))\n\t    return wrap_dispatch_unknown_iterable(object, typename ::Rcpp::traits::has_iterator<T>::type());\n        }\n\t// }}}\n\n\t// {{{ wrap dispatch\n    \t/**\n         * wrapping a __single__ primitive type : int, double, std::string, size_t,\n         * Rbyte, Rcomplex\n         */\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch(const T& object, ::Rcpp::traits::wrap_type_primitive_tag) {\n            return primitive_wrap(object);\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch(const T& object, ::Rcpp::traits::wrap_type_char_array) {\n            return Rf_mkString(object);\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch(const T& object, ::Rcpp::traits::wrap_type_module_object_pointer_tag) {\n            return Rcpp::internal::make_new_object< typename T::object_type >(object.ptr);\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch(const T& object, ::Rcpp::traits::wrap_type_module_object_tag) {\n            return Rcpp::internal::make_new_object<T>(new T(object));\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch(const T& object, ::Rcpp::traits::wrap_type_enum_tag) {\n            return wrap((int)object);\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_eigen(const T& object, ::Rcpp::traits::false_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_eigen<%s>(., false )\", DEMANGLE(T))\n            return wrap_dispatch_unknown(object, typename ::Rcpp::traits::is_convertible<T,SEXP>::type());\n        }\n\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_eigen(const T& object, ::Rcpp::traits::true_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_eigen<%s>(., true )\", DEMANGLE(T))\n            return ::Rcpp::RcppEigen::eigen_wrap(object);\n        }\n\n\n\t/**\n         * called when T is wrap_type_unknown_tag and is not an Importer class\n         * The next step is to try implicit conversion to SEXP\n         */\n    \ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown_importable(const T& object, ::Rcpp::traits::false_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown_importable<%s>(., false )\", DEMANGLE(T))\n            return wrap_dispatch_eigen(object, typename traits::is_eigen_base<T>::type());\n        }\n\n\t/**\n         * called when T is an Importer\n         */\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch_unknown_importable(const T& object, ::Rcpp::traits::true_type) {\n            RCPP_DEBUG_1(\"wrap_dispatch_unknown_importable<%s>(., true )\", DEMANGLE(T))\n            return wrap_dispatch_importer<T,typename T::r_import_type>(object);\n        }\n\n\t/**\n         * This is called by wrap when the wrap_type_traits is wrap_type_unknown_tag\n         *\n         * This tries to identify if the object conforms to the Importer class\n         */\n\ttemplate <typename T>\n        inline SEXP wrap_dispatch(const T& object, ::Rcpp::traits::wrap_type_unknown_tag) {\n\t    RCPP_DEBUG_1(\"wrap_dispatch<%s>(., wrap_type_unknown_tag)\", DEMANGLE(T))\n            return wrap_dispatch_unknown_importable(object, typename ::Rcpp::traits::is_importer<T>::type());\n        }\n\t// }}}\n\n\t// {{{ wrap a container that is structured in row major order\n\ttemplate <typename value_type, typename InputIterator>\n        inline SEXP rowmajor_wrap__dispatch(InputIterator first, int nrow, int ncol, ::Rcpp::traits::r_type_generic_tag) {\n            Shield<SEXP> out(::Rf_allocVector(VECSXP, nrow * ncol));\n            int i=0, j=0;\n            for (j=0; j<ncol; j++) {\n\t\tfor (i=0; i<nrow; i++, ++first) {\n                    SET_VECTOR_ELT(out, j + ncol*i, ::Rcpp::wrap(*first));\n\t\t}\n            }\n            Shield<SEXP> dims(::Rf_allocVector(INTSXP, 2));\n            INTEGER(dims)[0] = nrow;\n            INTEGER(dims)[1] = ncol;\n            ::Rf_setAttrib(out, R_DimSymbol, dims);\n            return out;\n        }\n\n\ttemplate <typename value_type, typename InputIterator>\n        inline SEXP rowmajor_wrap__dispatch(InputIterator first, int nrow, int ncol, ::Rcpp::traits::r_type_string_tag) {\n            Shield<SEXP> out(::Rf_allocVector(STRSXP, nrow * ncol));\n            int i=0, j=0;\n            for (j=0; j<ncol; j++) {\n\t\tfor (i=0; i<nrow; i++, ++first) {\n                    SET_STRING_ELT(out, j + ncol*i, make_charsexp(*first));\n\t\t}\n            }\n            Shield<SEXP> dims(::Rf_allocVector(INTSXP, 2));\n            INTEGER(dims)[0] = nrow;\n            INTEGER(dims)[1] = ncol;\n            ::Rf_setAttrib(out, R_DimSymbol, dims);\n            return out;\n        }\n\n    \ttemplate <typename value_type, typename InputIterator>\n        inline SEXP primitive_rowmajor_wrap__dispatch(InputIterator first, int nrow, int ncol, ::Rcpp::traits::false_type) {\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<value_type>::rtype;\n            Shield<SEXP> out(::Rf_allocVector(RTYPE, nrow * ncol));\n            value_type* ptr = r_vector_start<RTYPE>(out);\n            int i=0, j=0;\n            for (j=0; j<ncol; j++) {\n\t\tfor (i=0; i<nrow; i++, ++first) {\n                    ptr[ j + ncol*i ] = *first;\n\t\t}\n            }\n            Shield<SEXP> dims(::Rf_allocVector(INTSXP, 2));\n            INTEGER(dims)[0] = nrow;\n            INTEGER(dims)[1] = ncol;\n            ::Rf_setAttrib(out, R_DimSymbol, dims);\n            return out;\n        }\n\ttemplate <typename value_type, typename InputIterator>\n        inline SEXP primitive_rowmajor_wrap__dispatch(InputIterator first, int nrow, int ncol, ::Rcpp::traits::true_type) {\n            const int RTYPE = ::Rcpp::traits::r_sexptype_traits<value_type>::rtype;\n            typedef typename ::Rcpp::traits::storage_type<RTYPE>::type STORAGE;\n            Shield<SEXP> out(::Rf_allocVector(RTYPE, nrow * ncol));\n            STORAGE* ptr = r_vector_start<RTYPE>(out);\n            int i=0, j=0;\n            for (j=0; j<ncol; j++) {\n\t\tfor (i=0; i<nrow; i++, ++first) {\n                    ptr[ j + ncol*i ] = caster<value_type,STORAGE>(*first);\n\t\t}\n            }\n            Shield<SEXP> dims(::Rf_allocVector(INTSXP, 2));\n            INTEGER(dims)[0] = nrow;\n            INTEGER(dims)[1] = ncol;\n            ::Rf_setAttrib(out, R_DimSymbol, dims);\n            return out;\n\n        }\n\n\ttemplate <typename value_type, typename InputIterator>\n        inline SEXP rowmajor_wrap__dispatch(InputIterator first, int nrow, int ncol, ::Rcpp::traits::r_type_primitive_tag) {\n            return primitive_rowmajor_wrap__dispatch<value_type,InputIterator>(first, nrow, ncol, typename ::Rcpp::traits::r_sexptype_needscast<value_type>());\n        }\n\n    \ttemplate <typename InputIterator>\n        inline SEXP rowmajor_wrap(InputIterator first, int nrow, int ncol) {\n            typedef typename std::iterator_traits<InputIterator>::value_type VALUE_TYPE;\n            return rowmajor_wrap__dispatch<VALUE_TYPE,InputIterator>(first, nrow, ncol, typename ::Rcpp::traits::r_type_traits<VALUE_TYPE>::r_category());\n        }\n    \t// }}}\n\n    } // internal\n\n    /**\n     * wraps an object of type T in a SEXP\n     *\n     * This method depends on the Rcpp::traits::wrap_type_traits trait\n     * class to dispatch to the appropriate internal implementation\n     * method\n     *\n     */\n     template <typename T>\n     inline SEXP wrap(const T& object);\n\n     template <> inline SEXP wrap<Rcpp::String>(const Rcpp::String& object);\n\n     template <typename T>\n     inline SEXP module_wrap_dispatch(const T& obj, Rcpp::traits::void_wrap_tag) {\n         return R_NilValue;\n     }\n\n     // these are defined in wrap_end.h\n     template <typename T>\n     inline SEXP module_wrap_dispatch(const T& obj, Rcpp::traits::pointer_wrap_tag);\n\n     template <typename T>\n     inline SEXP module_wrap_dispatch(const T& obj, Rcpp::traits::normal_wrap_tag);\n\n     template <typename T>\n     inline SEXP module_wrap(const T& obj) {\n         return module_wrap_dispatch<T>(obj, typename Rcpp::traits::module_wrap_traits<T>::category());\n     }\n     template <>\n     inline SEXP module_wrap<SEXP>(const SEXP& obj) {\n         return obj;\n     }\n\n     inline SEXP wrap(const char* const v) {\n         if (v != NULL)\n             return Rf_mkString(v);\n         else\n             return R_NilValue; \t\t\t// #nocov \n     }\n\n     /**\n      * Range based version of wrap\n      */\n     template <typename InputIterator>\n     inline SEXP wrap(InputIterator first, InputIterator last) {\n         return internal::range_wrap(first, last);\n     }\n\n} // Rcpp\n\n#endif\n",
    "created" : 1604416146388.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3132907113",
    "id" : "2A22C2A7",
    "lastKnownWriteTime" : 1604312201,
    "last_content_update" : 1604312201,
    "path" : "~/R/x86_64-pc-linux-gnu-library/3.6/Rcpp/include/Rcpp/internal/wrap.h",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "h"
}